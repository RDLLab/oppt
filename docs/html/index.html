<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OPPT: OPPT</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OPPT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">OPPT </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a></li>
<li class="level1"><a href="#requirements">System Requirements</a></li>
<li class="level1"><a href="#dependencies">Dependencies</a></li>
<li class="level1"><a href="#building">Building OPPT</a></li>
<li class="level1"><a href="#configRuntime">Configuring the OPPT runtime environment</a></li>
<li class="level1"><a href="#quickStart">Quick start</a></li>
<li class="level1"><a href="#motionPlanning">Defining a motion planning problem</a></li>
<li class="level1"><a href="#general">Defining a general POMDP problem</a><ul><li class="level2"><a href="#plugins">POMDP plugins</a></li>
<li class="level2"><a href="#implCustomPlugins">Implementing custom POMDP plugins</a></li>
</ul>
</li>
<li class="level1"><a href="#impl">Implementing new solvers</a></li>
<li class="level1"><a href="#defCustomOptions">Defining custom options for solvers and plugins</a></li>
<li class="level1"><a href="#workWNormalized">Working with normalized spaces</a></li>
<li class="level1"><a href="#playVideoExec">Using the playVideo executable</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>On-line POMDP Planning Toolkit (OPPT) is a C++ software-toolkit for approximating POMDP solutions on-line. To ease implementation of POMDP models, OPPT allows users to specify the state, action, and observation spaces via a configuration file, and uses a plug-in architecture to implement the core components of a POMDP, that is, the transition, observation and reward functions. For standard motion planning under partial observability problems - that is, moving from one configuration to another with errors in the effect of actions and sensing -, OPPT provides a default POMDP model, such that users only need to specify 3D models of the robot and environment, and a configuration file that specifies parameters for the probability density functions that represent the uncertainty in the effect of actions, observations, and starting state, and the reward function.</p>
<p>OPPT also allows a user to separate the POMDP model (including the robotâ€™s environment) for planning and for simulated execution. It is known that developing a faithful POMDP model is often the main bottleneck in applications of POMDP based planning, today. However, it is also known that strategies computed with imperfect POMDP models can still generate relatively good robot behaviours. The ability to separate planning and execution environments will better facilitate sensitivity analysis studies of on-line POMDP solvers and allow users to better predict the performance of on-line POMDP solvers in the physical world. For testing new solvers, OPPT provides an abstract and general POMDP solver class that is not restricted to specific data structures. The user has access to a rich framework that provides functionalities common for many motion planning problems, such as kinematic computations, physical simulation of the robot and the environment it operates in and collision detection. This enables the user to focus on implementing new POMDP solvers</p>
<h1><a class="anchor" id="requirements"></a>
System Requirements</h1>
<ul>
<li>OS: Ubuntu 15.10 or higher</li>
<li><a href="https://gcc.gnu.org">GNU C++ compiler</a> (&gt;= 4.9.4) or equivalent</li>
</ul>
<h1><a class="anchor" id="dependencies"></a>
Dependencies</h1>
<ul>
<li>Gazebo v7.1.0 or higher and its dependencies for physics simulation and kinematic computations</li>
<li>Eigen v3.2.0 or higher for linear algebra computations</li>
<li>FCL v0.4.0 or higher for collision queries</li>
<li>Assimp v3.3.1 or higher for importing meshes</li>
<li>Boost v1.55.0 or higher (required packages: system, thread, timer, filesystem, serialization, program_options, signals, unit_test_framework)</li>
<li>TinyXML v2.6.2 or higher</li>
<li>spatialindex v1.8.5 or higher</li>
<li>(optional) ROS Kinetic or higher for visualization</li>
</ul>
<h2>Installing the dependencies</h2>
<h3>One-line installation</h3>
<p>Before building OPPT, you have to make sure that all the dependencies are installed. On a clean Ubuntu installation, use the following command to install the dependencies: </p><pre class="fragment">wget https://bitbucket.org/hoergems/oppt_scripts/downloads/install_dependencies.sh &amp;&amp; chmod +x install_dependencies.sh &amp;&amp; ./install_dependencies.sh
</pre><h3>Step-by-step installation</h3>
<ol type="1">
<li>Install the core dependencies <pre class="fragment"> sudo apt-get install build-essential git cmake mercurial pkg-config libboost-all-dev libtinyxml-dev libeigen3-dev libassimp-dev libfcl-dev
</pre></li>
<li>Install Gazebo and it's dependencies by following the instructions on the <a href="http://gazebosim.org/tutorials?tut=install_ubuntu&amp;cat=install">Gazebo website</a>.</li>
<li>Download and install libspatialindex-1.8.5 <pre class="fragment"> wget http://download.osgeo.org/libspatialindex/spatialindex-src-1.8.5.tar.gz
 tar zxfv spatialindex-src-1.8.5.tar.gz
 cd spatialindex-src-1.8.5
 mkdir build &amp;&amp; cd build
 cmake -DCMAKE_INSTALL_PREFIX=/usr/local ..
 make -j2 &amp;&amp; sudo make install
</pre></li>
<li>(Optional) If you want to use the GUI provided in OPPT or the Inverse Kinematics functionality, you need to have a working installation of ROS (at least the ROS-base stack along with the rviz, kdl-parser and trac-ik stack). Furthermore your ROS environment has to be set up (please refer to <a href="http://wiki.ros.org/">http://wiki.ros.org/</a>&lt;ROS distribution&gt;=""&gt;/Installation/Ubuntu section 1.6). If you do not have ROS installation, you can install it using <pre class="fragment"> sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'
 sudo apt-get update
 sudo apt-get install ros-&lt;ROS DISTRIBUTION&gt;-ros-base ros-&lt;ROS DISTRIBUTION&gt;-rviz ros-&lt;ROS DISTRIBUTION&gt;-kdl-parser ros-&lt;ROS DISTRIBUTION&gt;-trac-ik ros-&lt;ROS DISTRIBUTION&gt;-trac-ik-lib
</pre></li>
</ol>
<p>where *&lt;ROS_DISTRIBUTION&gt;* is the ROS distribution corresponding to your Ubuntu version.</p>
<h1><a class="anchor" id="building"></a>
Building OPPT</h1>
<ol type="1">
<li>Building and installing OPPT <pre class="fragment"> cd &lt;oppt_root_folder&gt;/src/
 mkdir build &amp;&amp; cd build
 cmake -DCMAKE_BUILD_TYPE=&lt;BUILD_TYPE&gt; -DCMAKE_INSTALL_PREFIX=&lt;oppt_install_location&gt; ..
 make &amp;&amp; make install
</pre></li>
</ol>
<p>OPPT supports three build types: Debug, RelWithDebInfo and Release. The default build type is RelWithDebInfo</p>
<h1><a class="anchor" id="configRuntime"></a>
Configuring the OPPT runtime environment</h1>
<p>In order to obtain resources such as SDF models, plugins, etc., OPPT uses a filesystem API </p><pre class="fragment">oppt::FileExists("filename")
oppt::FindFile("filename")
</pre><p>which locates resources inside folders specified in the </p><pre class="fragment">OPPT_RESOURCE_PATH
</pre><p>environment variable. To configure your current environment, either call </p><pre class="fragment">source &lt;oppt_install_location&gt;/share/oppt/setup.sh
</pre><p>or add this line to your bash environment file</p>
<p>This will add the </p><pre class="fragment">&lt;oppt_install_location&gt;/share/oppt/models
&lt;oppt_install_location&gt;/share/oppt/plugins
</pre><p>folders to the resource environment variable. If you want to add additional folders, use </p><pre class="fragment">export OPPT_RESOURCE_PATH=$OPPT_RESOURCE_PATH:&lt;additional_folder&gt;
</pre><p>If you have a working ROS installation, make sure that the ROS environment is set-up properly. For a clean ROS installation, this is done via </p><pre class="fragment">source /opt/ros/&lt;ROS DISTRIBUTION&gt;/setup.sh
</pre><p>If you fail to do this, you will get an 'ROS_MASTER_URI is not defined' error</p>
<h1><a class="anchor" id="quickStart"></a>
Quick start</h1>
<p>After OPPT was compiled successfully, navigate to the </p><pre class="fragment">&lt;oppt_root_folder&gt;/bin
</pre><p>directory. Here you should see the 'abt' executable. If you have installed the optional ROS dependency, you should see two additional executables, 'viewer' and 'playVideo'. The problem configuration files for the problems that ship with OPPT are inside the </p><pre class="fragment">&lt;oppt_root_folder&gt;/cfg
</pre><p>directory. To run the ABT solver for any of the problems, run </p><pre class="fragment">./abt --cfg &lt;oppt_root_folder&gt;/cfg/&lt;ProblemConfigurationFile&gt;.cfg
</pre><p>Note that the path to the problem configuration file must be an absolute path.</p>
<p>If you want a visualization of the simulation runs, open a separate terminal and run </p><pre class="fragment">opptViewer
</pre><p>BEFORE running the ABT solver.</p>
<h1><a class="anchor" id="motionPlanning"></a>
Defining a motion planning problem</h1>
<p>Before showing how to implement a specific POMDP model using the plugin architecture, we show how to define and set-up motion planning problems under uncertainty for which the standard plugin implementations can be used. In OPPT motion planning problems under uncertainty are a class of problems in which a robot starts from an initial belief and has to reach a goal area within the environment while avoiding collisions with static obstacles that are present within the environment. It is assumed that the robot consists of a set of links connected by revolute torque-controlled joints. Additionally the input torques of the joints are disturbed by additive multivariate Gaussian noise. Similarly the observations the robot receives are affected by additive multivariate Gaussian noise as well. For this class of problems, terminal states are states in which the robot either collides with an obstacle or reaches the goal area. For collisions with the obstacles the robot receives a user-defined penalty, for reaching the goal area it receives a user-defined reward. Additionally the robot receives a small penalty for every step it takes. If a planning problem under uncertainty falls within this class of problems, the standard plugins can be used. In this example we will show how to define a POMDP problem in which a 2DOF torque controlled manipulator that operates inside a 3D environment has to reach a goal area without colliding with an obstacle.</p>
<h3>Environment and robot model</h3>
<p>OPPT follows the Gazebo convention in defining environment and robot models, in particular using the SDF format to define models. A typical folder structure for environment and robot models looks as follows:</p>
<ul>
<li><em>ModelFolder</em> (this folder has to be added to the OPPT_RESOURCE_PATH environment variable)<ul>
<li><em>MyModelFolder</em><ul>
<li><em>MyModel.sdf</em></li>
<li><em>model.config</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The <em>MyModel.sdf</em> is the SDF file that describes your environment or robot model, whereas the <em>model.config</em> contains meta-information about your model and should have the following structure: </p><pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;model&gt;
  &lt;name&gt;MyModel&lt;/name&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;sdf version='1.6'&gt;MyModel.sdf&lt;/sdf&gt;

  &lt;author&gt;
    &lt;name&gt;My name&lt;/name&gt;
    &lt;email&gt;name@email.address&lt;/email&gt;
  &lt;/author&gt;

  &lt;description&gt;
    Description of MyModel
  &lt;/description&gt;
&lt;/model&gt;
</pre><p>The example 2DOF manipulator model files are located <em>models</em> folder inside the root folder of oppt, since this folder is automatically added to the <em>OPPT_RESOURCE_PATH</em> environment variable when sourcing the setup.sh shell script inside the <em>oppt_root</em> folder. If you navigate to the <em>models/2DOFManipulator</em> folder you will find the 2DOFManipulator model file and the corresponding <em>model.config</em>. The <em>2DOFManipulator.sdf</em> contains a full kinematic and dynamic description of the robot. Now we also need an environment the robot operates in. Navigate to the <em>models/2DOFEnvironment</em> folder and you will find the environment SDF and its corresponding model.config file.</p>
<p>To add our 2DOF manipulator to the environment, we can use an include reference: </p><pre class="fragment">&lt;include&gt;
  &lt;uri&gt;model://2DOFManipulator&lt;/uri&gt;
  &lt;pose&gt;0.0 0.0 0.0 0 0 0&lt;/pose&gt;
&lt;/include&gt;
</pre><p>You will also find a description of the Gazebo physics engine. As of now, ODE is the only supported physics engine. Another important component of a motion planning problem is the goal area the robot has to reach. The model of the goal area should have no *&lt;collision&gt;* tag, otherwise it is treated as an obstacle.</p>
<p>After we are finished defining our environment and robot model, we can provide a problem configuration file.</p>
<p>Note that while in this example we define the environment and robot models in separate SDF files, it is also possible to use a single SDF file which contains both the environment as well as the robot model.</p>
<h3>Problem configuration file</h3>
<p>The problem configuration file contains all the configuration parameters to set-up a POMDP planning problem in its entirety, including state, action and observation descriptions, solver parameters, etc. Navigate to the <em>cfg/</em> folder and you will see a bunch of problem configuration files for the various problems that are shipped with OPPT.</p>
<p>Let's have a look at the <em>2DOFManipulator.cfg</em> file, which is the problem configuration file for our 2DOFManipulator problem. A problem configuration file consists of <em>sections</em> and parameters for these section: </p><pre class="fragment">[section]
parameter1
parameter2
parameter2
</pre><p>The most important sections are the <em>plugins</em>, <em>state</em>, <em>action</em>, <em>observation</em> and <em>problem</em> sections. We will go through these sections using the 2DOFManipulator.cfg config file as an example. Looking at the 2DOFManipulator.cfg config file we see the following <em>plugins</em> section: </p><pre class="fragment">[plugins]
planningTerminalPlugin = libdefaultTerminalPlugin.so
executionTerminalPlugin = libdefaultTerminalPlugin.so

planningTransitionPlugin = libdefaultTransitionPlugin.so
executionTransitionPlugin = libdefaultTransitionPlugin.so

planningObservationPlugin = libdefaultObservationPlugin.so
executionObservationPlugin = libdefaultObservationPlugin.so

executionInitialBeliefPlugin = libdefaultInitialBeliefPlugin.so
planningInitialBeliefPlugin = libdefaultInitialBeliefPlugin.so

rewardPlugin = libdefaultRewardPlugin.so
heuristicPlugin = libRRTHeuristicPlugin.so
</pre><p>Here we specify which shared library will be used as the respective POMDP plugin. Note that for the transition, observation, terminal and initial belief plugins we have included the same plugin twice (with a 'planning' and 'execution' prefix). This is due to the fact that OPPT distinguishes between the plugins used when planning a policy, and the ones that are used when executing a policy. Since we assume for the 2DOFManipulator problem that the planning model is the same as the actual model, we use the same plugin libraries for both planning and execution. However, for other problems it is possible to use different plugins for planning and execution.</p>
<p>Note that the shared libraries specified inside the <em>plugins</em> section must reside inside a subdirectory of a folder that has been added to the <em>OPPT_RESOURCE_PATH</em> environment variable, e.g. inside the subdirectories of the &lt;oppt_root&gt;/plugins folder.</p>
<p>Following the <em>plugins</em> section, we can see severeal plugin options sections. We will cover these sections later. Next are the <em>state</em>, <em>action</em> and <em>observation</em> sections which specify the POMDP states, actions and observations: </p><pre class="fragment">[state]
jointPositions = [2DOFManipulator::joint1, 2DOFManipulator::joint2]
jointVelocities = [2DOFManipulator::joint1, 2DOFManipulator::joint2]
</pre><p>With this description, OPPT models the states of the robot as a 4D-vector consisting of the joint angles and joint velocities. Note that variables that refer to different elements of the robot (i.e. joints and links) have to be in the scope of the robot name. Looking at the jointPosition variables above, joint1 and joint2 and in the scope of 2DOFManipulator, as indicated by the double colon. Next, we have to specify the POMDP actions: </p><pre class="fragment">[action]
jointTorques = [2DOFManipulator::joint1, 2DOFManipulator::joint2]
</pre><p>This tells OPPT that the actions are 2D-vectors consisting of the joint torques. This specification also provides enough information to the GazeboInterface, such that an action vector is applied to the specified joints. Similarly, we have to specify the observations the robot can perceive: </p><pre class="fragment">[observation]
jointVelocities = [2DOFManipulator::joint1, 2DOFManipulator::joint2]
linkPoses = [2DOFManipulator::link2]    
</pre><p>This specifies that the observations are 8D-vectors consisting of the joint velocities and the 3D-pose of the second link. The additional dimensions can then be handled inside the respective plugin (in this case the <a class="el" href="classoppt_1_1TransitionPlugin.html">oppt::TransitionPlugin</a>).</p>
<p>The state, action and observation descriptions not only tell OPPT how the spaces are structured, it also configures the <a class="el" href="classoppt_1_1GazeboInterface.html">oppt::GazeboInterface</a> and the underlying physics engine. E.g. when stepping the physics engine forward in time using the <a class="el" href="classoppt_1_1GazeboInterface.html#a9551c27243ca4aaae45b7abac3069d03">oppt::GazeboInterface::doPropagation</a> interface the torques specified in the <em>jointTorques</em> parameter will be applied to the respective joints.</p>
<p>After the state, action and observation descriptions you will see a <em>problem</em> section. The parameters in this section configure the actual POMDP planning problem. The most important parameters in this section are the <em>planningEnvironmentPath</em> and <em>executionEnvironmentPath</em> parameters containing the environment SDF files for planning and execution. Additionally, <em>robotName</em> specifies the name of the model in our SDF file which corresponds to the robot. Note that the physical entities of the robot used for the state, action and observation descriptions must be consistent with the SDF model of the robot specified by the <em>robotName</em> parameter. For a full list of available options, see the <a class="el" href="structoppt_1_1ProblemEnvironmentOptions.html">oppt::ProblemEnvironmentOptions</a> documentation.</p>
<p>Additionally the problem configuration file has to contain the parameters for a particular POMDP solver. For the 2DOFManipulator.cfg config file we have already defined the parameters for ABT under the <em>ABT</em> section. For custom POMDP solvers it is possible to define additional parameters as outlined in section <a class="el" href="index.html#defCustomOptions">Defining custom options for solvers and plugins</a>.</p>
<h1><a class="anchor" id="general"></a>
Defining a general POMDP problem</h1>
<p>For problems that do not fall into the class of standard motion planning problems, such as grasping, target-tracking and environmental exploration problems, the user can provide custom implementations of the plug-ins that define a particular POMP problem. The plug-ins are designed such that only a small number of virtual methods have to be implemented.</p>
<h2><a class="anchor" id="plugins"></a>
POMDP plugins</h2>
<p>In OPPT the components of a POMDP are implemented via plugins. Plugins are shared libraries that are loaded dynamically during runtime. There are 5 plugin types, each of them modelling a specific component of a POMDP model. These are:</p>
<ul>
<li><a class="el" href="classoppt_1_1TransitionPlugin.html">oppt::TransitionPlugin</a></li>
<li><a class="el" href="classoppt_1_1ObservationPlugin.html">oppt::ObservationPlugin</a></li>
<li><a class="el" href="classoppt_1_1RewardPlugin.html">oppt::RewardPlugin</a></li>
<li><a class="el" href="classoppt_1_1TerminalPlugin.html">oppt::TerminalPlugin</a></li>
<li><a class="el" href="classoppt_1_1InitialBeliefPlugin.html">oppt::InitialBeliefPlugin</a></li>
<li><a class="el" href="classoppt_1_1HeuristicPlugin.html">oppt::HeuristicPlugin</a></li>
</ul>
<p>Note that the state-, action- and observation space components of a POMDP model are automatically constructed during run-time, therefore these components don't require a plugin type.</p>
<h3>TransitionPlugin</h3>
<p>In a POMDP model the transition function is a conditional probability distribution over the state space. It models the probability of ending up in state s' after taking action a from state s: P(s' | s, a). In OPPT the transition function is implicitly defined inside the <a class="el" href="classoppt_1_1TransitionPlugin.html">oppt::TransitionPlugin</a>. The <a class="el" href="classoppt_1_1TransitionPlugin.html#ad35d27e53262b790ac138b4f026a69f3" title="Perfom forward propagation based on a PropagationRequest. This method is the implicit definition of t...">oppt::TransitionPlugin::propagateState</a> method takes as an input a pointer to <a class="el" href="structoppt_1_1PropagationRequest.html">oppt::PropagationRequest</a>, which contains a state and an action, and returns a <a class="el" href="structoppt_1_1PropagationResult.html">oppt::PropagationResult</a> containing the next state. This can be seen as a black-box sampler of the actual transition probability distribution.</p>
<h3>ObservationPlugin</h3>
<p>Similarly to the TransitionPlugin, the <a class="el" href="classoppt_1_1ObservationPlugin.html">oppt::ObservationPlugin</a> implicitly models the observation function which is a conditional probability distribution over the observation space, given a state s and and action a, such that P(o | s, a). The <a class="el" href="classoppt_1_1ObservationPlugin.html">oppt::ObservationPlugin</a>:getObservation takes as an input a <a class="el" href="structoppt_1_1ObservationRequest.html">oppt::ObservationRequest</a> containing a state and an action outputs a <a class="el" href="structoppt_1_1ObservationResult.html">oppt::ObservationResult</a> containing the sampled observation.</p>
<h3>RewardPlugin</h3>
<p>The <a class="el" href="classoppt_1_1RewardPlugin.html">oppt::RewardPlugin</a> models the POMDP reward function, a function that maps states an actions to rewards. The <a class="el" href="classoppt_1_1RewardPlugin.html#a731ebc55e669bbcccac5ace6b428be91" title="Returns a reward given a oppt::PropagationResultSharedPtr. ">oppt::RewardPlugin::getReward</a> takes as an input a pointer to a oppt::PropagationResults, which containing a state, action, and next state, and outputs a reward.</p>
<h3>TerminalPlugin</h3>
<p>In OPPT the <a class="el" href="classoppt_1_1TerminalPlugin.html">oppt::TerminalPlugin</a> serves two purposes: It checks wheter a state is a terminal state (via the <a class="el" href="classoppt_1_1TerminalPlugin.html#a54815362cce0006df66982a84df7f5b7" title="Checks wheter a PropagationResult is valid. ">oppt::TerminalPlugin::isValid</a> method), or if a state is valid (via the <a class="el" href="classoppt_1_1TerminalPlugin.html#ade7b244325e4a69a6ac2155d3bb8540c" title="Checks wheter a PropagationResult leads to a terminal state. ">oppt::TerminalPlugin::isTerminal</a> method). In OPPT invalid states are always terminal but not the other way around (terminal states can still be valid)</p>
<h3>InitialBeliefPlugin</h3>
<p>The <a class="el" href="classoppt_1_1InitialBeliefPlugin.html">oppt::InitialBeliefPlugin</a> samples states according to an initial belief (via the <a class="el" href="classoppt_1_1InitialBeliefPlugin.html#a86a02f2afea79a4c97d4327c1877f8f5" title="Samples a state according to the initial belief. ">oppt::InitialBeliefPlugin::sampleAnInitState</a> method).</p>
<h3>Heuristic plugin</h3>
<p>Many POMDP solvers - such as the solver that shipps with OPPT, ABT - require a function that calculates an estimation of the Q-value given a particular state: A heuristic function. For this purpose OPPT uses an <a class="el" href="classoppt_1_1HeuristicPlugin.html">oppt::HeuristicPlugin</a>. Providing this plugin is optional. If one is provided, the solver has access to it via the <em>heuristicPlugin_</em> member.</p>
<h2><a class="anchor" id="implCustomPlugins"></a>
Implementing custom POMDP plugins</h2>
<p>Implementing custom plugins and using them for a specific problem model is simple. Here we will show an example implementation of a custom TransitionPlugin, which we will call MyTransitionPlugin. Navigate to the src/plugins/transitionPlugins folder. Here you will see a few folders that contain specific implementations of TransitionPlugins that are used for the various problem examples that are shipped with OPPT. Let's create a new folder called "MyTransitionPlugin". Inside this folder, create a source file "MyTransitionPlugin.cpp" with the following contents: </p><pre class="fragment">// Include the Plugins header file
#include "oppt/plugin/Plugin.hpp"

namespace oppt
{
class MyTransitionPlugin: public TransitionPlugin
{
public:
    MyTransitionPlugin():
        TransitionPlugin() {
    }

    virtual bool load(RobotEnvironment* const robotEnvironment, const std::string&amp; optionsFile) override { 
        // This method is called after the plugin has been instantiated.
        // The first parameter is a pointer to the robot planning environment whose functionality can be used within the plugin
        // The second parameter is the path to the problem configuration file            
    }

    virtual PropagationResultSharedPtr propagateState(const PropagationRequest* propagationRequest) const override { 
        // This method is called when a state has to be propagated via an action as specified in the propagationRequest
        // parameter
    }
};

// Here we need to register our plugin. This is done using the following preprocessor macro:
OPPT_REGISTER_TRANSITION_PLUGIN(MyTransitionPlugin)

} 
</pre><p>After we have provided an implementation of the <a class="el" href="classoppt_1_1TransitionPlugin.html">oppt::TransitionPlugin</a>, we have to build it as a shared library. In order to do this, create a new CMakeLists.txt inside the MyTransitionPlugin and add the ADD_TRANSITION_PLUGIN macro: </p><pre class="fragment">ADD_TRANSITION_PLUGIN(myTransitionPlugin SHARED
            ${CMAKE_CURRENT_LIST_DIR}/MyTransitionPlugin.cpp)
</pre><p>For the other plugin types, the user has access to the ADD_OBSERVATION_PLUGIN, ADD_INITIAL_BELIEF_PLUGIN, ADD_REWARD_PLUGIN, ADD_TERMINAL_PLUGIN and ADD_HEURISTIC_PLUGIN macros. To build your TransitionPlugin, navigate to the src/build folder and type 'make'. After successful compilation, the shared library for the transition plugin will be located inside the plugins/transitionPlugins folder. Now we can use our TransitionPlugin inside the problem configuration files: </p><pre class="fragment">[plugins]
planningTransitionPlugin = libmyTransitionPlugin.so
executionTransitionPlugin = libmyTransitionPlugin.so
</pre><h2>Using general state, action and observation descriptions</h2>
<p>In section problemConfFile we have seen how to define states, actions and observations by relating physical quantities of the robot (such as joint angles and joint torques) to the specific POMDP state, action and observation descriptions. In many cases this is insufficient for a complete state description. For this OPPT provides an additional integer paramerter <em>additionalDimensions</em>, where the user can specifiy the number of dimensions. An example of a state description using the <em>additionalDimension</em> parameter can be found inside the <em>cfg/Rocksample.cfg</em> problem configuration file: </p><pre class="fragment">[state]
# The first state dimension is the x-position of the robot
linkPositionsX = [RocksampleRobot::RocksampleLink]

# The second state dimension is the y-position of the robot
linkPositionsY = [RocksampleRobot::RocksampleLink]    

# Rock states
additionalDimensions = 8
</pre><p>With this the state of the robot is a 10-dimensional vector consisting of the xy-position of the robot and 8 additional dimensions describing the state of the environment.</p>
<h1><a class="anchor" id="impl"></a>
Implementing new solvers</h1>
<p>OPPT aims to ease the implementation of new POMP solvers. For this, OPPT provides a general <a class="el" href="classsolvers_1_1Solver.html">solvers::Solver</a> interface. To develop a new POMDP solver, the user needs to provide an implementation of the pure virtual methods <a class="el" href="classsolvers_1_1Solver.html#a8b24cedc98fca47ab58a377aa9c16cdb" title="Performs initial setup operations. ">solvers::Solver::setup</a>, <a class="el" href="classsolvers_1_1Solver.html#a148c66e8a1c0ee132c990795e39ad5d1" title="Perform reset operations. This method is called after each simulation run. ">solvers::Solver::reset</a>, <a class="el" href="classsolvers_1_1Solver.html#acdca5589d7ef19ce7328aa8998ffa9ba" title="Improve the POMDP policy starting from the current belief. ">solvers::Solver::improvePolicy</a>, <a class="el" href="classsolvers_1_1Solver.html#a85d0a6e0b28be333797f771e586e5f66" title="Get the next action the robot has to execute according to the calculated policy. ">solvers::Solver::getNextAction</a> and <a class="el" href="classsolvers_1_1Solver.html#abfdb79ee5eb5109932e7fe7825f82405" title="Update the belief, based on the action taken and observation received. ">solvers::Solver::updateBelief</a>. Inside these methods, a <a class="el" href="classsolvers_1_1Solver.html">solvers::Solver</a> has access to the <a class="el" href="classoppt_1_1RobotEnvironment.html">oppt::RobotEnvironment</a> (via the robotPlanningEnvironment_ member).</p>
<p>When a <a class="el" href="classoppt_1_1ProblemEnvironment.html">oppt::ProblemEnvironment</a> executes a POMDP problem, it repeatedly calls <a class="el" href="classsolvers_1_1Solver.html#acdca5589d7ef19ce7328aa8998ffa9ba" title="Improve the POMDP policy starting from the current belief. ">solvers::Solver::improvePolicy</a>, <a class="el" href="classsolvers_1_1Solver.html#a85d0a6e0b28be333797f771e586e5f66" title="Get the next action the robot has to execute according to the calculated policy. ">solvers::Solver::getNextAction</a> and <a class="el" href="classsolvers_1_1Solver.html#abfdb79ee5eb5109932e7fe7825f82405" title="Update the belief, based on the action taken and observation received. ">solvers::Solver::updateBelief</a> (in this order), until a terminal condition is met, according to the <a class="el" href="classoppt_1_1TerminalPlugin.html">oppt::TerminalPlugin</a>. Note that OPPT does not enforce a specific belief data structure. Depending on the solver, a belief can have very different representations, such as a set of particles or a multivariate-normal distribution. An implementation of <a class="el" href="classsolvers_1_1Solver.html">solvers::Solver</a> therefore has to provide its own internal belief data structure.</p>
<p>To provide a solver implementation, navigate to the src/solvers folder and create a new folder for your solver. In this example we will simply call it MySolver. Inside the src/solvers/MySolver folder, create a MySolver.hpp header file which contains the implementation of your solver. This header file should look like this: </p><pre class="fragment">#ifndef _MY_SOLVER_HPP_
#define _MY_SOLVER_HPP_

// Include the solver interface
#include "solvers/solver.hpp"

class MySolver: public solvers::Solver {
public:
    MySolver():
      solver::Solver() {}          

    virtual void setup() override {
        // Perform your set-up operations here, such as initializing the initial belief
    }        

    virtual bool reset() override {
        // Here you should reset your internal datastructures 
    }

    virtual bool improvePolicy(const double&amp; timeout) override {
        // Perform policy improvement starting from the current belief.
        // If the policy improvement was successful, return true,
        // otherwise return false
    }

    virtual ActionSharedPtr getNextAction() override {
        // Return the best action according to the policy calculated inside the improvePolicy() method.
        // If there is no action available, simply return a nullptr         
    }

    virtual bool updateBelief(const ActionSharedPtr&amp; action, const ObservationSharedPtr&amp; observation) override {
        // Update the current belief based on the action and the observation
        // and return true if the belief update was successful. Otherwise return false
    }

};

#endif
</pre><p>After we have provided a solver implementation, we need to provide a C++ main file that runs the <a class="el" href="classoppt_1_1ProblemEnvironment.html">oppt::ProblemEnvironment</a> using MySolver as the POMDP solver. Let's create a new mainfile 'main_mysolver.cpp' inside the src/solvers/MySolver folder with the following contents: </p><pre class="fragment">// Include the ProblemEnvironment
#include "oppt/problemEnvironment/ProblemEnvironment.hpp"

// Include our solver implementation
#include "MySolver.hpp"

// Include our solver options
#include "MySolverOptions.hpp"

int main(int argc, char const* argv[])
{    
    // First we need an instance of ProblemEnvironment
    oppt::ProblemEnvironment problemEnvironment;

    // Next we need to call the setup template, where the first template parameter is 
    // our solver and the second template parameter is our solver options.
    int ret = problemEnvironment.setup&lt;solvers::MySolver, oppt::MySolverOptions&gt;(argc, argv);

    // If the return code of setup is anything else but 0, we shouldn't go on
    if (ret != 0)
        return ret;

    // Now we run the problem using our solver
    return problemEnvironment.runEnvironment(argc, argv);
}
</pre><p>This main file will instantiate a <a class="el" href="classoppt_1_1ProblemEnvironment.html">oppt::ProblemEnvironment</a> and set it up so that the POMDP solver being used is MySolver. Next it will execute the environment.</p>
<p>So far the src/solvers/MySolver folder should contain MySolver.hpp and main_mysolver.cpp (and a MySolverOptions.hpp header that will be discussed in <a class="el" href="index.html#defCustomOptions">Defining custom options for solvers and plugins</a>). Now we need to create an executable for our solver. To do so we create a CMakeLists.txt inside the src/solvers/MySolver folder with the following contents: </p><pre class="fragment"># Add a target for the solver
add_executable(mysolver 
               ${CMAKE_CURRENT_LIST_DIR}/main_mysolver.cpp
               &lt;additional source files&gt;)

# Link the solver executable to the OPPT library
target_link_libraries(mysolver
                      oppt
                      &lt;additional libraries&gt;)
</pre><p>To build our solver, navigate to the src/build folder and type 'make'. Upon completion, you will find an executable 'mysolver' inside the bin folder. This executable can be used in a similar way as the already existing ABT solver: </p><pre class="fragment">./mysolver --cfg &lt;ProblemConfiguationFile&gt;
</pre><p>During execution the solver will automatically create a log file which contains information about the simulation runs. Per default, these log files are stored within the &lt;oppt_root&gt;/bin/log folder. If you want to store them in a different location, you have to change the 'logPath' option in your problem configuration file.</p>
<h1><a class="anchor" id="defCustomOptions"></a>
Defining custom options for solvers and plugins</h1>
<p>Within a problem configuration file the user has a wide variety of available options to influence the behaviour of the <a class="el" href="classoppt_1_1ProblemEnvironment.html">oppt::ProblemEnvironment</a> when running a solver for a specific problem. However, it is possible to define additional parameters used by a oppt::Solver or a custom plugin implementation if needed. This requires providing a <a class="el" href="structoppt_1_1Options.html">oppt::Options</a> struct that generates a parser for the user-defined options. Let's assume we have a problem configuration file where we need two additional parameters for our solver implementation of section <a class="el" href="index.html#impl">Implementing new solvers</a>, a bool parameter and a string parameter. Navigate to the src/solver/MySolver folder and add a MySolverOptions.hpp file with the following contents: </p><pre class="fragment">// Include the ProblemEnvironmentOptions data structure
#include "oppt/problemEnvironment/ProblemEnvironmentOptions.hpp"

namespace oppt {

// Our custom options data structure.
// By inheriting from oppt::ProblemEnvironmentOptions, the resulting options object
// will contain all members of the ProblemEnvironmentOptions data structure, plus
// the additional members defined here
struct MySolverOptions: public oppt::ProblemEnvironmentOptions {
    MySolverOptions() = default;
    virtual ~MySolverOptions() = default;

    // Our first custom parameter
    bool myBoolParameter;

    // Our second custom parameter
    std::string myStringParameter

    // Make a parser for our custom options datastructure
    static std::unique_ptr&lt;options::OptionParser&gt; makeParser(bool simulating) { 
        std::unique_ptr&lt;options::OptionParser&gt; parser =
            ProblemEnvironmentOptions::makeParser(simulating);
        addMyOptions(parser.get());  
        return std::move(parser);
    }

    static void addMyOptions(options::OptionParser* parser) {
        // Here we add our options to the parser using the addOption template. The
        // template parameter determines the type of our custom option

        // The first parameter is the section in the problem configuarion file
        // the option belongs to (can be empty). In this example both options
        // should be under MY_SECTION

        // The second parameter is the name of the custom option as used in the
        // problem configuration file.

        // The thid option is a reference to the MySolverOptions member this option belongs to
        parser-&gt;addOption&lt;bool&gt;("MY_SECTION", "myBoolParameter", &amp;MySolverOptions::myBoolParameter);

        // We want the second option to have a default value
        parser-&gt;addOptionWithDefault&lt;std::string&gt;("MY_SECTION", "myStringParameter", &amp;MHFROptions::myStringParameter, "defaultString");
    }
};
}
</pre><p>Going back to section <a class="el" href="index.html#impl">Implementing new solvers</a>, we can see that we have already included our MySolverOptions header in the main_mysolver.cpp: </p><pre class="fragment">#include "MySolverOptions.hpp"
</pre><p>Inside the main file, we set-up the <a class="el" href="classoppt_1_1ProblemEnvironment.html">oppt::ProblemEnvironment</a> to use our custom options data structure: </p><pre class="fragment">int ret = problemEnvironment.setup&lt;solvers::MySolver, oppt::MySolverOptions&gt;(argc, argv);
</pre><p>Now all we have to do is to add our options to the problem configuration file: </p><pre class="fragment">[MY_SECTION]
myBoolParameter = false
myStringParameter = "myString"
</pre><p>And inside our MySolver implementation we have access to our custom options: </p><pre class="fragment">static_cast&lt;MySolverOptions*&gt;(problemEnvironmentOptions_.get())-&gt;myBoolParameter;
</pre><p>Defining custom options for plugins works in a similar fashion. After we have defined a custom options struct for a particular plugin (see <a class="el" href="classoppt_1_1DefaultTransitionPluginOptions.html">oppt::DefaultTransitionPluginOptions</a> for an example), we can parse the options inside the load method of the plugin using </p><pre class="fragment">parseOptions_&lt;MyPluginOptions&gt;(optionsFile);
</pre><p>After this, we can use </p><pre class="fragment">static_cast&lt;MyPluginOptions*&gt;(options_.get())-&gt;optionsMember
</pre><p>to access our custom options.</p>
<h1><a class="anchor" id="workWNormalized"></a>
Working with normalized spaces</h1>
<p>OPPT provides an option to automatically normalize state-, action- and observation spaces such that each dimension of the spaces is normalized to the interval [0, 1]. This is useful for scaling the uncertainties a robot is subject to as well as simplifying theoretical analysis for solvers. When using normalized spaces, the state, action and observation limits have to be defined inside the problem configuration file. Example: </p><pre class="fragment">[state]
linkPositionsX = [link1, link2]

# The limits of the x-position of the two links
linkPositionXLimits = [[-10, 10], [-5, 5]]
</pre><p>Note that joint angle, velocitie and torque limits are deduced from the robot SDF model and don't have to be specifically defined inside the problem configuration file.</p>
<p>If required, normalized states, actions and observations can be de-normalized using the <a class="el" href="classoppt_1_1StateSpace.html#afe66bff6b80b9605be11916ff755517c" title="Denormalizes a RobotState If the oppt::ProblemEnvironmentOptions::normalizedSpaces is false...">oppt::StateSpace::denormalizeState</a>, <a class="el" href="classoppt_1_1ActionSpace.html#a24940d412d7140663bb7a2aa052d890a" title="Denormalizes an action If the oppt::ProblemEnvironmentOptions::normalizedSpaces is false...">oppt::ActionSpace::denormalizeAction</a> and <a class="el" href="classoppt_1_1ObservationSpace.html#ab142dc31fac9917a9ade59d3b11d3199" title="Denormalizes an observation If the oppt::ProblemEnvironmentOptions::normalizedSpaces is false...">oppt::ObservationSpace::denormalizeObservation</a> methods</p>
<h1><a class="anchor" id="playVideoExec"></a>
Using the playVideo executable</h1>
<p>As mentioned in <a class="el" href="index.html#impl">Implementing new solvers</a>, running a solver on a specific problem produces a log file. These log files can be replayed using the <em>playVideo</em> executable inside the &lt;oppt_root&gt;/bin folder. Make sure that you have started the viewer (see section <a class="el" href="index.html#quickStart">Quick start</a>) in a separate terminal window before replaying a log file: </p><pre class="fragment">cd &lt;oppt_root&gt;/bin
./playVideo --cfg &lt;ProblemConfigurationFile&gt; --logfile &lt;LogFile&gt;
</pre><p>where the <em>cfg</em> parameter is the path to the problem configuration file and the <em>-f</em> parameter the path to the log file (both paths must be absolute). For additional command line options, use </p><pre class="fragment">./playVideo --help
</pre><hr/>
 <h2>OPPT Development Team </h2>
<ul>
<li>Main developers:<ul>
<li>Marcus Hoerger (OPPT toolkit)</li>
<li>Dimitri Klimenko (ABT solver)</li>
<li>Konstantin Seiler (continuous action spaces for ABT) </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
